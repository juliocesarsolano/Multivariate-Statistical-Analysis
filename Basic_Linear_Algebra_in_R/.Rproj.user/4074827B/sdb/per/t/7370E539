{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Algrebra Lineal Basica con R\"\nauthor: \"Created By Julio SOLANO\"\ndate: \"April 24, 2017\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n## 1. Vectores\n\n* Muchas operaciones realizadas sobre datos multivariables son facilitados usando la notación de vector y matriz.\n* Utilizaremos letras minusculas pra denotar vectores.\n\n```{r vectors, echo=TRUE}\n\n# draw the vector\n\nplot(c(1,1),c(2,2), xlim=c(0,5), ylim=c(0,5))\narrows(0, 0, 1, 2)\ntext(1.3, 2, \"v=(1,2)\")\n\n\nx <- seq(2,8,2)\nx\n\ny <- 4:1\ny\n\nx+y # Suma de vectores\n\ncrossprod(x,y) # crossprod retorna matriz 1x1, no un escalar.\n\ncrossprod(x)\nx*y   # Multiplicación de vectores elemento por elemento\n\nx\n\nx %o% x # Producto xx’, es uma matriz nxn\n\n(x %o% x)[, 3] # Fila 3 del producto xx’. Tratado como vector \n\n(x %o% x)[2,] # Fila 2 del producto xx’. Tratado como vector \n\ndiag(1, 4, 4) # Matriz identidad 4x4\n\nmatrix(1, 4, 4) # Matriz 4x4 com todos sus elementos = 1\n\n```\n\n\n## 2. Matrices\n\n* Para crear una matriz en R se utiliza la función: \n**matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)**\n\ndonde matrix() corresponde al nombre de la función y todo lo que esta dentro de los parentesis son los argumentos de dicha funcion.  \n- **data**\tes un vector de datos opcional  \n- **nrow**\tnúmero deseado de filas  \n- **ncol**\tnúmero deseado de columnas  \n- **byrow**\tvalor lógico. Si es falso (valor por defecto), la matriz se llena por orden columna, de otra manera se llenara primero por filas  \n- **dimnames** utilizado para darles nombres a las filas y a las columnas, respectivamente  \n\n* Utilizaremos letras mayúsculas para denotar matrices.\n\n* Para obtener más informacion sobre las matrices escriba **?matrix** y ejecutelo pulsando enter si trabaja directamente en la pagina principal de R o pulsando Ctrl + r si trabaja desde un script.\n\n```{r matrix, echo=TRUE}\n\nM1 <- matrix(data = c(5, 7, 13, 4, 1, 7, 14, 3, 11), nrow=3, ncol=3, byrow=F, dimnames=list(c(\"Blanco\", \"Negro\", \"Rojo\"), c(\"Toyota\", \"Audi\", \"Nissan\")))\nM1\n\nAzul<-c(8,5,7) # Agregando filas: con esto creamos el vector Azul con sus correspondientes elementos \nM2 <- rbind(M1, Azul)\n\nHyundai<-c(2,7,3,5) # Agregando columnas: con esto creamos el vector Hyundai con sus correspondientes elementos \nM3 <- cbind(M1, Hyundai)\n\nmatrix(1:16, 4, 4) # Matriz 4x4 del 1 al 16\n\n# Otra manera de crear matrices es a traves de vectores, los cuales seran nuestras columnas\na <- c(1,2,3,4,5,6)\nb <- c(2,3,5,6,1,9)\nc <- c(3,5,5,5,10,8)\nd <- c(10,20,30,40,50,55)\ne <- c(7,8,9,4,6,10)\n\n# Crear una matriz a partir de los vectores anteriores\nM4 <- cbind(a,b,c,d,e)\nM4\n\n# Más formas de crear matrices... \nM5 <- matrix(c( 5, -1, -2,\n               4,  4, -1,\n              -2,  5, -3,\n              -7, -8,  6),\n            byrow = T, nrow = 4, ncol = 3,\n            dimnames = list(c(\"P1\", \"P2\", \"P3\", \"P4\"), c(\"V1\", \"V2\", \"V3\")))\nM5\n\nM6 <- matrix(sample(c(0:100), 100, replace = FALSE), 10, 10) # Matriz 10x10 del 1 al 100\nM6\n\n# Dimensión de una matriz (mxn)\ndim(M4)\n\nt(matrix(1:16, 4, 4)) # Transpuesta de una matriz\n\ndiag(t(matrix(1:16, 4, 4))) # Extrae la diagonal\n\nA <- matrix(data= c(1,2,3,2,4,6,3,6,9,4,8,12), nrow=3, ncol=4, byrow=F)\nA\n\nB <- matrix(data= c(2,4,6,4,8,12,6,12,18,8,16,24), nrow=3, ncol=4, byrow=F)\nB\n\nt(B) # Transpuesta de B (B'), se convierte en una matriz 4x3\n\n# data freme to matrix\nmy.matrix <- as.matrix(M5)\nclass(M5)\n\n```\n\n\n### 2.1. Suma de Matrices\nDos matrices son conformables para la suma y resta si son de la misma dimension, teniendo esto en mente, en R podemos facilmente sumar y restar matrices indicando la suma con + y la resta con –\n\n```{r sum, echo=TRUE}\n\nA+B # Suma matricial\n\n```\n\n\n### 2.2. Multiplicacion de Matrices\nHay dos formas de multiplicar matrices: la multiplicacion elemento a elemento y la multiplicacion definida por el ?lgebra matricial donde debe cumplirse la condicion de conformabilidad   para la multiplicacion donde el numero de columnas de la primera matriz debe ser igual al número de filas de la segunda. Para multiplicar dos matrices elemento a elemento, estas deben ser de igual dimension.\n\nLa multiplicación elemento a elemento se indica con el símbolo ** * ** y la multiplicacion matricial con los simbolos **%*%**.\n\n\n```{r mult, echo=TRUE}\n\nA*B # Multiplicacion elemento por elemento\n\nA%*%t(B) # Multiplicacion matricial, 3x3\n\n```\n\n\n### 2.3. Determinante de una Matriz\nPara obtener el determinante de cualquier matriz, se usa la función **det()**, recuerdese que para poder calcular el determinante de cualquier matriz esta debe ser cuadrada.\n\n```{r det, echo=TRUE}\n\nD <- matrix(data = rnorm(25), nrow=5, ncol=5)\nD\n\ndet(D)\n\n```\n\n\n### 2.4. Inversa de una Matriz\nEs muy sencillo calcular la inversa de una matriz en R, todo lo que se necesita es aplicar la funcion **solve()** a la matriz de la cual se desea obtener su inversa. *Es importante tener en en cuenta que sOlo las matrices cuyo determinante sea diferente de cero tiene tienen una inversa definida (son invertibles)*.\n\n```{r solve, echo=TRUE}\n\nA <- matrix(data=c(2,1,2,1,1,3,0,2,0), nrow = 3, ncol = 3, byrow = FALSE)\nA\n\ndetA <- det(A) # Para verificar si A es invertible det(A)!=0\ndetA\n\nInvA <- round(solve(A), digits = 3)\n\nA %*% InvA\n\n```\n\n\n### 2.5. Extrayendo la diagonal principal de una Matriz mxm\nEn ocasiones es muy importante trabajar sólo con los valores de la diagonal principal de una matriz, por ejemplo en el caso de la diagonal de la matriz de varianzas y covarianzas, donde la diagonal contienen los valores de las varianzas de las variables aleatorias, en este caso resultara util contar con una funcion que nos proporciones esa informacion dada una matriz, esa funcion es **diag()**.\n\n```{r diag, echo=TRUE}\ndiag(M1)\n```\n\n### 2.6. Generacion de una matriz unitaria mxm\nSi a la funcion diag() en vez de proporcionarle una matriz para que nos devuelva su diagonal, le proporcionamos un número (un escalar) nos devuelve una matriz unitaria con elementos en su diagonal principal igual al número que le hemos proporcionado y de dimensión igual a ese mismo número multiplicado por él mismo, puesto que la matriz unitaria es cuadrada, es decir que si a R le decimos que ejecute diag(3) nos construirá una matriz unitaria 3x3.\n\n```{r munit, echo=TRUE}\ndiag(10)\n```\n\n\n### 2.7. Vector de Medias (filas y columnas)\n\n```{r means, echo=TRUE}\n\na <- c(1,2,3,4,5,6)\nb <- c(2,3,5,6,1,9)\nc <- c(3,5,5,5,10,8)\nd <- c(10,20,30,40,50,55)\ne <- c(7,8,9,4,6,10)\n\nM4 <- cbind(a,b,c,d,e)\nM4\n\nrowMeans(M4)[1:6]  # Vector de medias por filas (row means)\napply(M4,1,mean)[1:6]  # Vector de medias por filas (row means), otra manera\n\nrowMeans(M4)[1:5]  # Vector de medias por columnas (column means)\napply(M4,2,mean)[1:5]\napply(M4,2,median)[1:5]\napply(M4,2,range)[1:5]\n\n```\n\n\n## 3. Sistemas de Ecuaciones Lineales\n\nResolvamos el sistema:\n\n$x + y + 2z   = 3$  \n$2x + 4y – 3z = -3$  \n$3x + 6y -5z  = -5$  \n\n$AX=b$      \n\n$X= Inv(A)b$  \n\n```{r sistem, echo=TRUE}\n\nA <- matrix(data= c(1,2,3,1,4,6,2,-3,-5), nrow=3, ncol=3, byrow=F)\nA\n\nb <- c(3,-3,-5)\nb\n\nX <- solve(A,b)\nX\n\n```\n\n\n## 4. Matriz de Varianzas y Covarianzas\n\nEn R utilizamos la funcion **cov()**\n\n```{r cova, echo=TRUE}\n\na <- c(1,2,3,4,5,6)\nb <- c(2,3,5,6,1,9)\nc <- c(3,5,5,5,10,8)\nd <- c(10,20,30,40,50,55)\ne <- c(7,8,9,4,6,10)\n\nM4 <- cbind(a,b,c,d,e)\nM4\n\ncov(M4)\n\n# Ahora hagamos este mismo calculo de forma manual\nk <- ncol(M4) # numero de variables\nn <- nrow(M4) # numero de observaciones (sujetos)\n \n# Crea medias por columnas\nM4_mean <- matrix(data=1, nrow=n) %*% cbind(mean(a),mean(b),mean(c),mean(d),mean(e)) \n \n# Crea una matriz centrada (C)\nCM4 <- M4 - M4_mean\n \n# Crea la matriz de covarianza\ncovM4 <- round(((n-1)^-1) * t(CM4)  %*%  CM4, digits=3)\ncovM4\n\n```\n\n\n## 5. Matriz de Correlacion\n\nEn R utilizamos la funcion **cor()**\n\n```{r corr, echo=TRUE}\n\na <- c(6,-3,4)\nb <- c(2,4,-4)\nc <- c(8,1,5)\n\nM5 <- cbind(a,b,c)\nM5\n\nround(cor(M5), digits = 2)\n\n```\n\n\n## 6. EigenValores y EigenVectores\n\nEn R utilizamos la funcion **eigen()**\n\n```{r eigen, echo=TRUE}\n\nE <- matrix(c(13, -4, 2, -4, 11, -2, 2, -2, 8), 3, 3, byrow=TRUE) # Corresponde a una matriz de Varianza-Covarianza\nE\n\nev <- eigen(E) # Extrae los componentes\n\nvalores <- ev$values # Se reportan en orden decreciente\nvalores\n\nvectores <- round(ev$vectors, digits = 3)\nvectores\n\nprod(eigen(E)$values)\ndet(E)\n\n```\n\n\n## 7. Single value decomposition of a Matrix\n\nAny matrix A can be decomposed as $A=UDV^T$, where:  \n* D is a diagonal matrix, with d=rank(A) non-zero elements  \t\n* The fist d rows of U are orthogonal basis for col(A)   \n* The fist d rows of V are orthogonal basis for row(A)  \n\nEn R utilizamos la funcion **svd()**  \n\n        # y$d: vector containing the singular values of a Matrix  \n        # y$u: matrix with columns contain the left singular vectors of a Matrix   \n        # y$v: matrix with columns contain the right singular vectors of a Matrix  \n\n```{r svd, echo=TRUE}\n\nsvd.matrix <- svd(E)\n\nsvd.matrix$d\nsvd.matrix$u\nsvd.matrix$v\n\n```\n\n\n## 8. El rango de una Matriz\n\nThe rank of a n x m matrix A, rk(A) is the maximal number of linearly independent columns (or rows); hence rk(A) <= min(n,m).\n\n```{r rank, echo=TRUE}\n\nrequire(Matrix)\n\nA <- diag( seq(1, 4, 1))\nA\nrankMatrix(A, method = \"tolNorm2\")\n\nB <- matrix(seq(1, 16, 1), nrow=4, byrow=TRUE)\nB\nrankMatrix(B, method = \"tolNorm2\")\n```\n\n\n# Anexos\n### Particion del Set de Datos (Training, Testing) - using sample function\n```{r, partition, warning=FALSE, message=FALSE}\n\nset.seed(12351) # setting seed to reproduce results of random sampling\ntrainingRowIndex <- sample(1:nrow(M6), 0.85*nrow(M6))  # row indices for training data\ntraining <- M6[trainingRowIndex, ]  # model training data\ntesting  <- M6[-trainingRowIndex, ]   # test data\ndim(training); dim(testing)\n\n```\n\n\n### Particion del Set de Datos (Training, Testing) - using caret package\n```{r message=FALSE, warning=FALSE}\n\nlibrary(caret)\n        # inTrain <- createDataPartition(y = data$Factor, p = 0.6, list = FALSE)\n        # training <- data[inTrain,]; testing <- data[-inTrain,]\n        # dim(training); dim(testing)\n\n```\n",
    "created" : 1524615039661.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "402792574",
    "id" : "7370E539",
    "lastKnownWriteTime" : 1528650191,
    "last_content_update" : 1528650216416,
    "path" : "E:/1.Data/6. MONTAJE DE CURSOS/5. Geostatistics/BS_GROUP_2018/Multivariate_Statistical_Analysis/Basic_Linear_Algebra_in_R/Basic_Linear_Algebra_in_R.Rmd",
    "project_path" : "Basic_Linear_Algebra_in_R.Rmd",
    "properties" : {
        "last_setup_crc32" : "3849AD21bb338d19",
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}